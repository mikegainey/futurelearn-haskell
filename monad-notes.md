### from Bob Vila from a YouTube comment: https://www.youtube.com/watch?v=gEoruozy3mk

Here is my quick beginner guide to monads in Haskell. Remember that the power of functional programming is all about the composition of functions, so make sure you have a good grasp on that. Monads are kind of a way to supercharge function composition so that it does something extra as well. The bind function (>>=) is just this supercharged function composition with added behavior. Each type of monad is like a context that you can apply to a computation to tell it what that extra behavior should be when things are composed.

For example in the Maybe monad the context is "this computation could fail". The added behavior, then, when we compose these functions using bind is "If any of them fail, the whole thing fails". In the List monad the context is "this computation could produce any number of results". The added behavior when we compose these functions using bind is then "take all of those returned values and pass them all through the next function". In the State monad the context is "for this computation to produce a result it relies on some state that it might change". The added behavior when we compose these functions using bind is then "thread that state (which might have been changed) through to the next computation". In the IO monad the context is "this computation has side effects/is impure". The added behavior when we compose these functions can kind of be thought of as "I understand that this result is impure so pass it along to the next function anyway".

So in general these things can be done without monads, but using them abstracts away a lot of boilerplate and confusing patterns. When you see a new monad, just think "what is the context of one of these computations" and then "what is the extra behavior that is added to composing these kinds of computations". Also, if you can think of another context like this and some added behavior that would go along with composing functions of that type, then you can write your own monad. There are technically some monad laws that your implementation should abide by but honestly you don't have to worry too much about that mathematical side of it (unless you are going to publish a library or something).ï»¿
